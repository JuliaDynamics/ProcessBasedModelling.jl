var documenterSearchIndex = {"docs":
[{"location":"","page":"Documentation","title":"Documentation","text":"ProcessBasedModelling","category":"page"},{"location":"#ProcessBasedModelling","page":"Documentation","title":"ProcessBasedModelling","text":"ProcessBasedModelling.jl\n\n(Image: docsdev) (Image: docsstable) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nProcessBasedModelling.jl is an extension to ModelingToolkit.jl (MTK) for building a model of equations using symbolic expressions. It is an alternative framework to MTK's native component-based modelling, but, instead of components, there are \"processes\". This approach is useful in the modelling of physical/biological/whatever systems, where each variable corresponds to a particular physical concept or observable and there are few (or none) duplicate variables to make the definition of MTK \"factories\" worthwhile. On the other hand, there plenty of different physical representations, or processes to represent a given physical concept. In many scientific fields this approach parallels the modelling reasoning of the researcher more closely than the \"components\" approach.\n\nBeyond this reasoning style, the biggest strength of ProcessBasedModelling.jl is the informative errors and automation it provides regarding incorrect/incomplete equations. When building the MTK model via ProcessBasedModelling.jl the user provides a vector of \"processes\": equations or custom types that have a well defined and single left-hand-side variable. This allows ProcessBasedModelling.jl to:\n\nIterate over the processes and collect new variables that have been introduced by a provided process but do not themselves have a process assigned to them.\nFor these collected \"process-less\" variables:\nIf there is a default process defined, incorporate this one into the model\nIf there is no default process but the variable has a default value, equate the variable to a parameter that has the same default value and throw an informative warning.\nElse, throw an informative error saying exactly which originally provided variable introduced this new \"process-less\" variable.\nThrow an informative error if a variable has two processes assigned to it (by mistake).\n\nIn our experience, and as we also highlight explicitly in the online documentation, this approach typically yields simpler, less ambiguous and more targeted warning or error messages than the native MTK one's, leading to faster identification and resolution of the problems with the composed equations.\n\nProcessBasedModelling.jl is particularly suited for developing a model about a physical/biological/whatever system and being able to try various physical \"rules\" (couplings, feedbacks, mechanisms, ...) for a given physical observable efficiently. This means switching arbitrarily between different processes that correspond to the same variable. Hence, the target application of ProcessBasedModelling.jl is to be a framework to develop field-specific libraries that offer predefined processes without themselves relying on the existence of context-specific predefined components. An example usage is in EnergyBalanceModels.jl.\n\nBesides the informative errors, ProcessBasedModelling.jl also\n\nProvides a couple of common process subtypes out of the box to accelerate development of field-specific libraries.\nMakes named MTK variables and parameters automatically, corresponding to parameters introduced by the by-default provided processes. This typically leads to intuitive names without being explicitly coded, while being possible to opt-out.\nProvides some utility functions for further building field-specific libraries.\n\nSee the documentation online for details on how to use this package as well as examples highlighting its usefulness.\n\n\n\n\n\n","category":"module"},{"location":"","page":"Documentation","title":"Documentation","text":"note: Basic familiarity with ModelingToolkit.jl\nThese docs assume that you have some basic familiarity with ModelingToolkit.jl. If you don't going through the introductory tutorial of ModelingToolkit.jl should be enough to get you started!","category":"page"},{"location":"#Usage","page":"Documentation","title":"Usage","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"In ProcessBasedModelling.jl, each variable is governed by a \"process\". Conceptually this is just an equation that defines the given variable. To couple the variable with the process it is governed by, a user either defines simple equations of the form \"variable = expression\", or creates an instance of Process if the left-hand-side of the equation needs to be anything more complex. In either case, the variable and the expression are both symbolic expressions created via ModellingToolkit.jl (more specifically, via Symbolics.jl).","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"Once all the processes about the physical system are collected, they are given as a Vector to the processes_to_mtkmodel central function, similarly to how one gives a Vector of Equations to e.g., ModelingToolkit.ODESystem. This function also defines what quantifies as a \"process\" in more specificity.","category":"page"},{"location":"#Example","page":"Documentation","title":"Example","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"Let's say we want to build the system of equations","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"dotz = x^2 - z \ndotx = 01y \ny = z - x","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"symbolically using ModelingToolkit.jl (MTK). We define","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"using ModelingToolkit\nusing OrdinaryDiffEq: Tsit5\n\n@variables t # independent variable\n@variables z(t) = 0.0\n@variables x(t) # no default value\n@variables y(t) = 0.0","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"ProcessBasedModelling.jl (PBM) strongly recommends that all defined variables have a default value at definition point. Here we didn't do this for x to illustrate what how such an \"omission\" will be treated by PBM.","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"To make the equations we want, we can use MTK directly, and call","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"eqs = [\n  Differential(t)(z) ~ x^2 - z\n  Differential(t)(x) ~ 0.1y\n  y ~ z - x\n]\n\nmodel = ODESystem(eqs, t; name = :example)\n\nequations(model)","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"All good. Now, if we missed the process for one variable (because of our own error/sloppyness/very-large-codebase), MTK will throw an error when we try to structurally simplify the model (a step necessary before solving the ODE problem):","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"model = ODESystem(eqs[1:2], t; name = :example)\ntry\n  model = structural_simplify(model)\ncatch e\n  return e.msg\nend","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"As you can see, the error message is unhelpful even with such a trivial system of equations, as all variables are reported as \"potentially missing\". At least on the basis of our scientific reasoning however, both x z have an equation. It is y that x introduced that does not have an equation. Moreover, in our experience these errors messages become increasingly less useful when a model has many equations and/or variables, as many variables get cited as \"missing\" from the variable map even when only one should be.","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"PBM resolves these problems and always gives accurate error messages when it comes to the construction of the system of equations. This is because on top of the variable map that MTK constructs automatically, PBM requires the user to implicitly provide a map of variables to processes that govern said variables. PBM creates the map automatically, the only thing the user has to do is to define the equations in terms of what processes_to_mtkmodel wants (which are either Processes or Equations as above).","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"Here is what the user defines to make the same system of equations via PBM:","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"using ProcessBasedModelling\n\nprocesses = [\n    ExpRelaxation(z, x^2),      # introduces x variable\n    TimeDerivative(x, 0.1*y),   # introduces y variable\n    y ~ z - x,                  # can be an equation because LHS is single variable\n]","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"which is then given to","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"model = processes_to_mtkmodel(processes; name = :example)\nequations(model)","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"Notice that the resulting MTK model is not structural_simplify-ed, to allow composing it with other models. By default t is taken as the independent variable.","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"Now, in contrast to before, if we \"forgot\" a process, PBM will react accordingly. For example, if we forgot the 2nd process, then the construction will error informatively, telling us exactly which variable is missing, and because of which processes it is missing:","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"try\n  model = processes_to_mtkmodel(processes[[1, 3]])\ncatch e\n  return e.msg\nend","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"If instead we \"forgot\" the y process, PBM will not error, but instead warn, and make y equal to a named parameter:","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"model = processes_to_mtkmodel(processes[1:2])\nequations(model)","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"parameters(model)","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"Lastly, processes_to_mtkmodel also allows the concept of \"default\" processes, that can be used for introduced \"process-less\" variables. Default processes are like processes and given as a 2nd argument to process_to_mtkmodel. For example,","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"model = processes_to_mtkmodel(processes[1:2], processes[3:3])\nequations(model)","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"does not throw any warnings as it obtained a process for y from the given default processes.","category":"page"},{"location":"#Special-handling-of-timescales","page":"Documentation","title":"Special handling of timescales","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"In dynamical systems modelling the timescale associated with a process is a special parameter. That is why, if a timescale is given for either the TimeDerivative or ExpRelaxation processes, it is converted to a named @parameter by default:","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"processes = [\n    ExpRelaxation(z, x^2, 2.0),    # third argument is the timescale\n    TimeDerivative(x, 0.1*y, 0.5), # third argument is the timescale\n    y ~ z-x,\n]\n\nmodel = processes_to_mtkmodel(processes)\nequations(model)","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"parameters(model)","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"This special handling is also why each process explicitly declares a timescale via the timescale function that one can optionally extend.","category":"page"},{"location":"#Main-API-function","page":"Documentation","title":"Main API function","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"processes_to_mtkmodel","category":"page"},{"location":"#ProcessBasedModelling.processes_to_mtkmodel","page":"Documentation","title":"ProcessBasedModelling.processes_to_mtkmodel","text":"processes_to_mtkmodel(processes::Vector, default::Vector = []; kw...)\n\nConstruct a ModelingToolkit.jl model using the provided processes and default processes.\n\nprocesses is a vector whose elements can be:\n\nAny instance of a subtype of Process.\nAn Equation which is of the form variable ~ expression with variable a single variable resulting from an @variables call.\nA vector of the above two, which is then expanded. This allows the convenience of functions representing a physical process that may require many equations to be defined.\n\ndefault is a vector that can contain the first two possibilities only as it contains default processes that may be assigned to variables introduced in processes but they don't themselves have an assigned process.\n\nIt is expected that downstream packages that use ProcessBasedModelling.jl to make a field-specific library implement a 1-argument version of processes_to_mtkmodel, or provide a wrapper function for it, and add a default value for default.\n\nKeyword arguments\n\ntype = ODESystem: the model type to make\nname = nameof(type): the name of the model\nindependent = t: the independent variable (default: @variables t). t is also exported by ProcessBasedModelling.jl for convenience.\n\n\n\n\n\n","category":"function"},{"location":"#predefined_processes","page":"Documentation","title":"Predefined Process subtypes","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"ParameterProcess\nTimeDerivative\nExpRelaxation","category":"page"},{"location":"#ProcessBasedModelling.ParameterProcess","page":"Documentation","title":"ProcessBasedModelling.ParameterProcess","text":"ParameterProcess(variable, value = default_value(variable)) <: Process\n\nThe simplest process which equates a given variable to a constant value that is encapsulated in a parameter. If value isa Real, then a named parameter with the name of variable and _0 appended is created. Else, if valua isa Num then it is taken as the paremeter directly.\n\nExample:\n\n@variables T(t) = 0.5\nproc = ParameterProcess(T)\n\nwill create the equation T ~ T_0, where T_0 is a @parameter with default value 0.5.\n\n\n\n\n\n","category":"type"},{"location":"#ProcessBasedModelling.TimeDerivative","page":"Documentation","title":"ProcessBasedModelling.TimeDerivative","text":"TimeDerivative(variable, expression [, τ])\n\nThe second simplest process that equates the time derivative of the variable to the given expression while providing some conveniences over manually constructing an Equation.\n\nIt creates the equation τ_$(variable) Differential(t)(variable) ~ expression by constructing a new @parameter with default value τ (if τ is already a @parameter, it is used as-is). If τ is not given, then 1 is used at its place and no parameter is created.\n\nNote that if iszero(τ), then the process variable ~ expression is created.\n\n\n\n\n\n","category":"type"},{"location":"#ProcessBasedModelling.ExpRelaxation","page":"Documentation","title":"ProcessBasedModelling.ExpRelaxation","text":"ExpRelaxation(variable, expression [, τ]) <: Process\n\nA common process for creating an exponential relaxation of variable towards the given expression, with timescale τ. It creates the equation:\n\nτn*Differential(t)(variable) ~ expression - variable\n\nWhere τn is a new named @parameter with the value of τ and name τ_($(variable)). If instead τ is nothing, then 1 is used in its place (this is the default behavior). If iszero(τ), then the equation variable ~ expression is created instead.\n\nThe convenience function\n\nExpRelaxation(process, τ)\n\nallows converting an existing process (or equation) into an exponential relaxation by using the rhs(process) as the expression in the equation above.\n\n\n\n\n\n","category":"type"},{"location":"#Process-API","page":"Documentation","title":"Process API","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"This API describes how you can implement your own Process subtype, if the existing predefined subtypes don't fit your bill!","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"Process\nProcessBasedModelling.lhs_variable\nProcessBasedModelling.rhs\nProcessBasedModelling.timescale\nProcessBasedModelling.NoTimeDerivative\nProcessBasedModelling.lhs","category":"page"},{"location":"#ProcessBasedModelling.Process","page":"Documentation","title":"ProcessBasedModelling.Process","text":"A process subtype p::Process extends the following unexported functions:\n\nlhs_variable(p) which returns the variable the process describes (left-hand-side variable). There is a default implementation lhs_variable(p) = p.variable if the field exists.\nrhs(p) which is the right-hand-side expression, i.e., the \"actual\" process.\n(optional) timescale(p), which defaults to NoTimeDerivative.\n(optional) lhs(p) which returns the left-hand-side. Let τ = timescale(p). Then default lhs(p) behaviour depends on τ as follows:\nJust lhs_variable(p) if τ == NoTimeDerivative().\nDifferential(t)(p) if τ == nothing.\nτ_var*Differential(t)(p) if τ isa Union{Real, Num}. If real, a new named parameter τ_var is created that has the prefix :τ_ and then the lhs-variable name and has default value τ. Else if Num, τ_var = τ as given.\nExplicitly extend lhs_variable if the above do not suit you.\n\n\n\n\n\n","category":"type"},{"location":"#ProcessBasedModelling.lhs_variable","page":"Documentation","title":"ProcessBasedModelling.lhs_variable","text":"ProcessBasedModelling.lhs_variable(p::Process)\n\nReturn the variable (a single symbolic variable) corresponding to p.\n\n\n\n\n\n","category":"function"},{"location":"#ProcessBasedModelling.rhs","page":"Documentation","title":"ProcessBasedModelling.rhs","text":"ProcessBasedModelling.rhs(p::Process)\n\nReturn the right-hand-side of the equation that p represents as an Expression. See Process for more.\n\n\n\n\n\n","category":"function"},{"location":"#ProcessBasedModelling.timescale","page":"Documentation","title":"ProcessBasedModelling.timescale","text":"ProcessBasedModelling.timescale(p::Process)\n\nReturn the timescale associated with p. See Process for more.\n\n\n\n\n\n","category":"function"},{"location":"#ProcessBasedModelling.NoTimeDerivative","page":"Documentation","title":"ProcessBasedModelling.NoTimeDerivative","text":"ProcessBasedModelling.NoTimeDerivative()\n\nSingleton value that is the default output of the timescale function for variables that do not vary in time autonomously, i.e., they have no d/dt derivative and hence the concept of a \"timescale\" does not apply to them.\n\n\n\n\n\n","category":"type"},{"location":"#ProcessBasedModelling.lhs","page":"Documentation","title":"ProcessBasedModelling.lhs","text":"ProcessBasedModelling.lhs(p::Process)\n\nReturn the left-hand-side of the equation that p represents as an Expression. If timescale is implemented for p, typically lhs does not need to be as well. See Process for more.\n\n\n\n\n\n","category":"function"},{"location":"#Utility-functions","page":"Documentation","title":"Utility functions","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"default_value\nhas_variable\nnew_derived_named_parameter\n@convert_to_parameters","category":"page"},{"location":"#ProcessBasedModelling.default_value","page":"Documentation","title":"ProcessBasedModelling.default_value","text":"default_value(x)\n\nReturn the default value of a symbolic variable x or nothing if it doesn't have any. Return x if x is not a symbolic variable.\n\n\n\n\n\n","category":"function"},{"location":"#ProcessBasedModelling.has_variable","page":"Documentation","title":"ProcessBasedModelling.has_variable","text":"has_variable(eq, var)\n\nReturn true if variable var exists in the equation(s) eq, false otherwise. Function works irrespectively if var is an @variable or @parameter.\n\n\n\n\n\n","category":"function"},{"location":"#ProcessBasedModelling.new_derived_named_parameter","page":"Documentation","title":"ProcessBasedModelling.new_derived_named_parameter","text":"new_derived_named_parameter(variable, value, extra::String, suffix = true)\n\nIf value isa Num, return value. Otherwise, create a new MTK @parameter whose name is created from variable by adding the extra string. If suffix = true the extra is added at the end after a _. Otherwise it is added at the start, then a _ and then the variable name.\n\n\n\n\n\n","category":"function"},{"location":"#ProcessBasedModelling.@convert_to_parameters","page":"Documentation","title":"ProcessBasedModelling.@convert_to_parameters","text":"@convert_to_parameters vars...\n\nConvert all variables vars into @parameters with name the same as vars and default value the same as the value of vars. Example:\n\n``` julia> A, B = 0.5, 0.5 (0.5, 0.5)\n\njulia> @converttoparameters A B 2-element Vector{Num}:  A  B\n\njulia> typeof(A) # A is not a number anymore! Num\n\njulia> default_value(A) 0.5\n\n\n\n\n\n","category":"macro"}]
}
